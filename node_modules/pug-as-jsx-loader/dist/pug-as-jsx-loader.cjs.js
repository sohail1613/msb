'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var pugAsJsxUtils = require('pug-as-jsx-utils');
var loaderUtils = require('loader-utils');
var j$1 = _interopDefault(require('jscodeshift'));

const j = require('jscodeshift');

const babylon = require('@babel/parser');

const parser = {
  parse(code) {
    return babylon.parse(code, {
      sourceType: 'module',
      allowImportExportEverywhere: true,
      allowReturnOutsideFunction: true,
      startLine: 1,
      tokens: true,
      plugins: ['jsx', 'asyncGenerators', 'bigInt', 'classPrivateMethods', 'classPrivateProperties', 'classProperties', 'decorators-legacy', 'doExpressions', 'dynamicImport', 'exportDefaultFrom', 'exportExtensions', 'exportNamespaceFrom', 'functionBind', 'functionSent', 'importMeta', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', ['pipelineOperator', {
        proposal: 'minimal'
      }], 'throwExpressions', 'typescript']
    });
  }

};

const getSource = (source, file) => {
  const fileExt = file.split('.').pop();

  if (fileExt === 'ts' || fileExt === 'tsx') {
    return j(source, {
      parser
    });
  }

  return j(source);
};

/* eslint-disable no-param-reassign */

const fs = require('fs');

const path = require('path');

const glob = require('glob'); // templateFn.call(this, { ... })


const isTemplateWithThis = (p, templateFuncs) => p.node.callee.object && templateFuncs.indexOf(p.node.callee.object.name) !== -1 && p.node.callee.property && p.node.callee.property.name === 'call'; // templateFn({ ... })


const isTemplateWithoutThis = (p, templateFuncs) => !p.node.callee.object && !p.node.callee.property && templateFuncs.indexOf(p.node.callee.name) !== -1;

const compareVariables = (a, b) => {
  const nameA = a.key.name.replace(/^unused_/, '');
  const nameB = b.key.name.replace(/^unused_/, '');
  const priorityA = nameA.search(/^[A-Z]/) !== -1 ? 1 : 0;
  const priorityB = nameB.search(/^[A-Z]/) !== -1 ? 1 : 0;

  if (priorityA === priorityB) {
    if (nameA === nameB) {
      return 0;
    }

    return nameA > nameB ? 1 : -1;
  }

  return priorityA > priorityB ? 1 : -1;
};

const getLinkedJsFiles = files => {
  const linkedJsFiles = glob.sync(path.join(files.path, '*.{js,jsx,ts,tsx}')).filter(file => file.search('.pug.transpiled.jsx') === -1).map(file => {
    const content = fs.readFileSync(file, 'utf8');
    const templateFuncs = getSource(content, file).find(j$1.ImportDeclaration).nodes().filter(e => {
      if (e.specifiers && e.specifiers.length === 1 && e.source.value.search('./') === 0 && path.join(files.path, e.source.value) === path.join(files.path, files.pug)) {
        return true;
      }

      return false;
    }).map(e => e.specifiers[0].local.name);
    return {
      file,
      content,
      templateFuncs
    };
  }).filter(e => e.templateFuncs.length > 0);
  return linkedJsFiles;
};

const codemod = ({
  useThis,
  variables
}, resourcePath) => {
  try {
    const filePath = resourcePath.split(path.sep).join('/');
    const files = {
      path: filePath.replace(/\/[^/]+$/, ''),
      pug: `./${filePath.replace(/\.[a-zA-Z0-9]+$/, '').split('/').pop()}.pug`
    };
    const printOptions = {
      quote: 'single',
      trailingComma: true
    };
    const jsFiles = getLinkedJsFiles(files);
    jsFiles.forEach(({
      file,
      content,
      templateFuncs
    }) => {
      let commentRemoved = content;
      getSource(content, file).find(j$1.CallExpression).filter(ce => isTemplateWithThis(ce, templateFuncs) || isTemplateWithoutThis(ce, templateFuncs)).forEach(ce => {
        const templateFuncName = ce.node.callee.object ? ce.node.callee.object.name : ce.node.callee.name;
        commentRemoved = commentRemoved.replace(new RegExp(`${templateFuncName}(.call)?\\([\\s\\S]+?}\\);`, 'g'), whole => whole.replace(/\/\/.*?\n/g, '\n'));
      });
      const breadcrumbs = {};
      const root = getSource(commentRemoved, file).find(j$1.CallExpression).filter(ce => isTemplateWithThis(ce, templateFuncs) || isTemplateWithoutThis(ce, templateFuncs)).forEach(ce => {
        const withThis = isTemplateWithThis(ce, templateFuncs);
        const templateFuncName = ce.node.callee.object ? ce.node.callee.object.name : ce.node.callee.name;
        let variableExists = false;
        let componentExists = false;
        let properties = (((ce.node.arguments || [])[withThis ? 1 : 0] || {}).properties || []).map(p => {
          const pureName = p.key.name.replace(/^unused_/, '');

          if (variables.indexOf(pureName) !== -1) {
            p.key.name = pureName;
          } else if (variables.indexOf(p.key.name) === -1) {
            p.key.name = `unused_${pureName}`;
          }

          delete p.comments;
          return p;
        });
        const oldVars = properties.map(p => p.key.name);
        properties = [...properties, ...variables.filter(p => oldVars.indexOf(p) === -1).map(e => j$1.objectProperty(j$1.identifier(e), j$1.identifier(e)))].sort(compareVariables).map(p => {
          if (!variableExists && p.key.name.search(/^[A-Z]/) === -1) {
            p.comments = [j$1.commentLine(' variables')];
            variableExists = true;
          }

          if (!componentExists && p.key.name.search(/^[A-Z]/) !== -1) {
            p.comments = [j$1.commentLine(' components')];
            componentExists = true;
          }

          if (p.value.type === 'JSXElement') {
            const jsxCode = j$1(p.value).toSource().trim(); // Wrap jsx code with parenthesis: keep

            if (jsxCode.search(/^\(/) === -1) {
              const key = `jsx__${Math.random().toString(36).substr(-6)}`;
              breadcrumbs[key] = jsxCode;
              p.value = j$1.literal(key);
            }
          }

          p.shorthand = p.key.name === p.value.name;
          return p;
        });

        if (useThis) {
          ce.node.callee = j$1.memberExpression(j$1.identifier(templateFuncName), j$1.identifier('call'));
          ce.node.arguments = [j$1.thisExpression(), properties.length > 0 ? j$1.objectExpression(properties) : null].filter(e => e);
        } else {
          ce.node.callee = j$1.identifier(templateFuncName);
          ce.node.arguments = [properties.length > 0 ? j$1.objectExpression(properties) : null].filter(e => e);
        }
      }); // Wrap jsx code with parenthesis: write down

      let result = Object.keys(breadcrumbs).reduce((prev, key) => prev.replace(new RegExp(`\n(\\s+)(.*?):\\s+'${key}'`), (whole, p1, p2) => `\n${p1}${p2}: (\n${breadcrumbs[key].split('\n').map(e => `${p1}  ${e}`).join('\n')}\n${p1})`), root.toSource(printOptions));
      templateFuncs.forEach(templateFunc => {
        result = result.replace(new RegExp(`${templateFunc}(.call)?\\([\\s\\S]+?}\\);`, 'g'), whole => whole.replace(/\n\s*\n/g, '\n'));
      });

      if (result !== content) {
        fs.writeFileSync(file, result, 'utf8');
      }
    });
  } catch (err) {
    console.error(err);
  }
};

const fs$1 = require('fs');

const path$1 = require('path');

function loader(source) {
  const options = loaderUtils.getOptions(this) || this;
  const {
    transform,
    pragma,
    autoFix
  } = options || {};
  const rootDir = (options || {}).rootDir || this.rootContext;
  const {
    resourcePath
  } = this;
  let resolve = {};

  if (options.resolve) {
    resolve = { ...options.resolve
    };
  } else {
    // for legacy props
    if (options.resolveComponents) {
      resolve = Object.entries(options.resolveComponents).reduce((prev, [name, moduleName]) => ({ ...prev,
        [moduleName]: {
          name
        }
      }), resolve);
    }

    if (options.resolveVariables) {
      resolve = Object.entries(options.resolveVariables).reduce((prev, [name, moduleName]) => ({ ...prev,
        [moduleName]: {
          name
        }
      }), resolve);
    }
  } // process pug in js


  if (this.resourcePath.split('.').pop().search(/^js/) !== -1 || source.match(/\s+pug`[\s\S]+`/)) {
    let useMacro = false;
    let jsxTemplate = source.replace(/(\n)?(\s*)?(.*)\s+pug`([\s\S]+?)`/g, (whole, _p0, _p1, p2, p3) => {
      const {
        jsx,
        useMacro: macroFound
      } = pugAsJsxUtils.pugToJsx(p3, {
        template: true,
        resolve,
        transform,
        pragma,
        autoFix,
        rootDir,
        resourcePath
      });

      if (macroFound) {
        useMacro = true;
      }

      const p0 = _p0 || '';
      const p1 = _p1 || '';
      const code = jsx.split(/\n/).map(e => ' '.repeat(p1.length + 2) + e).join('\n');
      return `${p0}${p1}${p2} (\n${code}\n${p1})`;
    });

    if (useMacro) {
      jsxTemplate = `import __macro from 'pug-as-jsx-loader/lib/macro';\n\n${jsxTemplate}`;
    }

    return options.detail ? {
      jsxTemplate,
      variables: []
    } : jsxTemplate;
  }

  const result = pugAsJsxUtils.pugToJsx(source, {
    template: true,
    resolve,
    transform,
    pragma,
    autoFix,
    rootDir,
    resourcePath
  });
  const {
    jsxTemplate,
    usage,
    useThis,
    variables
  } = result;

  if (options.autoUpdateJsFile) {
    codemod({
      useThis,
      variables
    }, this.resourcePath);
  }

  const basename = this.resourcePath.split(path$1.sep).pop().replace(/\.[a-zA-Z0-9]+$/, '');
  const code = jsxTemplate.replace(/%BASENAME%/g, `./${basename}`);

  if (options.transpiledFile) {
    const transpiledJsx = this.resourcePath.replace(/(\.[a-zA-Z0-9]+)$/, '$1.transpiled.jsx');
    const usageExample = ['/* USAGE EXAMPLE */', usage.replace(/%BASENAME%/g, basename), '/* // USAGE EXAMPLE */'].join('\n').split('\n').map(e => `//  ${e}`).join('\n');
    fs$1.writeFileSync(transpiledJsx, `${code}\n\n${usageExample}\n`, 'utf8');
  }

  return options.detail ? { ...result,
    jsxTemplate: code
  } : code;
}

module.exports = loader;
//# sourceMappingURL=pug-as-jsx-loader.cjs.js.map
