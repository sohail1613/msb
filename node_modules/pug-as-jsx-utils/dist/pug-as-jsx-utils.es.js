import pug from 'pug';
import prettier from 'prettier';
import j$1 from 'jscodeshift';
import babel from '@babel/core';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

var escapeStringRegexp = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }

  return str.replace(matchOperatorsRe, '\\$&');
};

const reservedWords = ['Object', 'String', 'Number', 'Array', 'JSON', 'Math', 'null'];

const isReactElement = node => node.parent.parent.node.type === 'JSXElement' && node.node.name.search(/^[a-z]/) === 0;

const arrayUnique = myArray => myArray.filter((v, i, a) => a.indexOf(v) === i);

const analyzeJsx = (jsxOutput, options = {}) => {
  const jsxRoot = j$1(jsxOutput);
  const varsToIgnore = [...reservedWords, ...(options.ignore || [])]; // Remove the use of local parameters.

  jsxRoot.find(j$1.ArrowFunctionExpression).replaceWith(nodePath => {
    // Get a list of function param names.
    const funcParamNames = j$1(nodePath.node.params).nodes().reduce((prev, param) => {
      if (param.type === 'ObjectPattern' && param.properties) {
        return [...prev, ...param.properties.filter(p => p.type === 'Property' && p.key).map(p => p.key.name), ...param.properties.filter(p => p.type === 'RestElement' && p.argument && p.argument.type === 'Identifier' && p.argument.name).map(p => p.argument.name)];
      }

      if (param.type === 'Identifier' && param.name) {
        return [...prev, param.name];
      }

      return prev;
    }, []);
    nodePath.node.params = []; // Remove function parameter usage.

    j$1(nodePath.node.body).find(j$1.MemberExpression).filter(me => {
      if (me.node.object && funcParamNames.indexOf(me.node.object.name) !== -1) {
        return true;
      }

      return false;
    }).remove();
    j$1(nodePath.node.body).find(j$1.Identifier).filter(p => {
      const parentNodeType = p.parent.node.type;
      return parentNodeType !== 'JSXAttribute' && !(parentNodeType === 'MemberExpression' && p.parent.node.computed === false) && funcParamNames.indexOf(p.node.name) !== -1;
    }).remove(); // console.log(jsc(nodePath).toSource());

    return nodePath.node;
  }); // Remove this pattern: const { props1, props2 } = params;

  jsxRoot.find(j$1.VariableDeclaration).filter(p => p.node.declarations[0].init.name === 'params').remove();
  const useThis = jsxRoot.find(j$1.MemberExpression, {
    object: {
      type: 'ThisExpression'
    },
    property: {
      type: 'Identifier'
    }
  }).nodes().length > 0; // Get used variable names.

  let variables = [];
  jsxRoot.find(j$1.Identifier).filter(p => {
    if (p.parent.node.type === 'MemberExpression' && p.parent.node.object === p.node) {
      return true;
    }

    if (p.parent.node.type === 'JSXExpressionContainer' && p.parent.node.expression === p.node) {
      return true;
    }

    if (p.parent.node.type === 'Property' && p.parent.parent.node.type === 'ObjectExpression' && ['CallExpression', 'JSXExpressionContainer'].indexOf(p.parent.parent.parent.node.type) !== -1 && p.parent.node.key === p.node) {
      return false;
    } // exclude nested JSXElement. ex) Modal.Body


    if (p.parent.node.type === 'JSXMemberExpression' && p.parent.node.property === p.node) {
      return false;
    }

    if (isReactElement(p) || p.parent.node.type === 'JSXAttribute' || p.parent.node.type === 'MemberExpression' && p.parent.node.computed === false) {
      return false;
    } // exclude object key


    if (p.parent.node.type === 'Property' && p.parent.node.key === p.node) {
      return false;
    } // exclude require call


    if (p.parent.node.type === 'CallExpression' && p.node.name === 'require') {
      return false;
    }

    return true;
  }).forEach(p => {
    variables = [...variables, p.node.name];
  });
  variables = arrayUnique(variables.filter(e => varsToIgnore.indexOf(e) === -1)).sort(); // Get require.

  let requires = {};
  jsxRoot.find(j$1.JSXAttribute).filter(p => {
    const {
      value
    } = p.node;

    if (value.type === 'JSXExpressionContainer') {
      const {
        expression
      } = value;

      if (expression && expression.type === 'CallExpression' && expression.callee && expression.callee.name === 'require') {
        return true;
      }
    }

    return false;
  }).forEach(p => {
    const {
      value: {
        expression
      }
    } = p.node;
    const [target] = expression.arguments;

    if (/^(['"]).*\1$/.test(target.raw)) {
      const key = hashCode(target.value);
      requires[`require\\(${escapeStringRegexp(target.raw)}\\)`] = [`require_${key}`, target.value];
    }
  });
  return {
    useThis,
    useMacro: !!variables.find(e => e === '__macro'),
    useFragment: !!variables.find(e => e === 'Fragment'),
    useRequire: !!Object.keys(requires).length,
    variables: variables.filter(e => ['__macro', 'Fragment'].indexOf(e) === -1),
    requires
  };
};

const hashCode = str => {
  let hash = 0;

  if (typeof str === 'object' && str !== null) {
    str = JSON.stringify(str);
  }

  if (!str || str.length === 0) {
    return hash;
  }

  let i = 0;
  const len = str.length;

  while (i < len) {
    const chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
    i += 1;
  }

  const base16 = hash.toString(16).replace(/[^a-z0-9]/g, '');
  const base36 = hash.toString(36).replace(/[^a-z0-9]/g, '');
  hash = (parseInt(base16.substr(0, 1), 16) + 10).toString(36) + base36;
  return hash;
};

function entries(object) {
  return Object.keys(object).map(key => [key, object[key]]);
}

function values(object) {
  return Object.keys(object).map(key => object[key]);
}

function gerResolveDict(resolveOpt = {}) {
  const resolveDict = entries(resolveOpt).map(([moduleName, detail]) => {
    const options = typeof detail === 'string' ? {
      name: detail
    } : detail;
    let member = options.member || {};

    if (Array.isArray(member)) {
      member = member.filter(memberName => memberName && typeof memberName === 'string').reduce((prev, memberName) => ({ ...prev,
        [memberName]: memberName
      }), {});
    }

    return { ...options,
      moduleName,
      member: entries(member).reduce((prev, [alias, memberName]) => ({ ...prev,
        [alias]: memberName && typeof memberName === 'string' ? memberName : alias
      }), {})
    };
  });
  return resolveDict.reduce((prev, {
    moduleName,
    name,
    member
  }) => {
    const next = { ...prev
    };

    if (name) {
      next[name] = {
        moduleName,
        type: 'name',
        name
      };
    }

    entries(member).forEach(([alias, memberName]) => {
      next[alias] = {
        moduleName,
        type: 'member',
        name: memberName
      };

      if (alias !== memberName) {
        next[alias].alias = alias;
      }
    });
    return next;
  }, {});
}

function getImports(variables, resolveOpt = {}) {
  const resolveDict = gerResolveDict(resolveOpt);
  const {
    used,
    imports
  } = variables.reduce((prev, each) => {
    const matched = resolveDict[each];

    if (!matched) {
      return prev;
    }

    const next = { ...prev
    };
    next.used.push(each);
    const item = prev.imports && prev.imports[matched.moduleName] || {
      moduleName: matched.moduleName
    };

    if (matched.type === 'name') {
      item.name = matched.name;
    }

    if (matched.type === 'member') {
      const newMember = {
        name: matched.name
      };

      if (matched.alias) {
        newMember.alias = matched.alias;
      }

      item.member = [...(item.member || []), newMember];
    }

    return { ...next,
      imports: { ...next.imports,
        [item.moduleName]: { ...(next.imports[item.moduleName] || {}),
          ...item
        }
      }
    };
  }, {
    used: [],
    imports: {}
  });
  return {
    used,
    imports: values(imports)
  };
}

function getUsage({
  useThis,
  variables
}) {
  const {
    components,
    params
  } = variables.reduce((prev, e) => {
    if (e.search(/^[A-Z]/) === 0 && e.search(/[a-z]/) !== -1) {
      return { ...prev,
        components: [...prev.components, e]
      };
    }

    return { ...prev,
      params: [...prev.params, e]
    };
  }, {
    components: [],
    params: []
  });
  let examples = [];

  if (components.length > 0) {
    examples = ['// components', ...components.map(e => `import ${e} from '__modulePath__/${e}';`), ''];
  }

  examples = [...examples, '// jsx', "import template from './%BASENAME%.pug';", '', 'class Sample extends React.Component {', '  render() {'];

  if (variables.length === 0) {
    examples = [...examples, '    return template();'];
  } else {
    if (params.length > 0) {
      examples = [...examples, '    const {', `      ${params.join(', ')}`, '    } = this;', ''];
    }

    examples = [...examples, useThis ? '    return template.call(this, {' : '    return template({'];

    if (params.length > 0) {
      examples = [...examples, '      // variables', `      ${params.join(', ')},`];
    }

    if (components.length > 0) {
      examples = [...examples, '      // components', `      ${components.join(', ')},`];
    }

    examples = [...examples, '    });'];
  }

  examples = [...examples, '  }', '}'];
  return prettier.format(examples.join('\n'), {
    parser: 'babel',
    printWidth: 120,
    tabWidth: 2,
    useTabs: false,
    semi: true,
    singleQuote: true,
    jsxSingleQuote: false,
    bracketSpacing: true,
    jsxBracketSameLine: false,
    trailingComma: 'es5'
  });
}

function removeDupAttrs(pugCode) {
  return pugCode.replace(/([^\s])\(([^()]{0,}?)\)/g, (whole, p0, p1) => {
    const matched = ` ${p1.replace(/\n/g, ' ')} `.replace(/\s+([a-zA-Z0-9_-]+)(\s*=\s*(('.*?')|(".*?")))/g, ' $1=$3').match(/([a-zA-Z0-9_-]+(\s*=\s*(('.*?')|(".*?"))){1,})|(?<=^|\s+)[a-zA-Z0-9_-]+($|\s+)/g);

    if (!matched) {
      return whole;
    }

    const attrs = matched.map(e => {
      const [key, ...rest] = e.split('=');
      const value = rest.join('=');
      return {
        key,
        value
      };
    }).reduce((prev, {
      key,
      value
    }) => {
      const next = { ...prev
      };

      if (next[key]) {
        delete next[key];
      }

      return { ...next,
        [key]: value
      };
    }, {});
    const replacement = Object.entries(attrs).map(([k, v]) => v ? `${k}=${v}` : k).join(', ');
    return `${p0}(${replacement})`;
  });
}

function removeIndent(source) {
  const lines = source.split(/\n/);
  const minIndent = lines.reduce((indentSize, curr) => {
    const indent = Array(curr.search(/[^\s]/) + 1).join(' ');

    if (curr.trim() && (indentSize === null || indent.length < indentSize)) {
      return indent.length;
    }

    return indentSize;
  }, null);
  return lines.map(e => e.substr(minIndent || 0)).join('\n').trim();
}

function removePugComment(pugCode) {
  return pugCode.split(/\n/).reduce((prev, curr) => {
    const indentSize = curr.match(/^\s*/)[0].length;

    if (prev.commentIndentSize !== null && (prev.commentIndentSize < indentSize || curr.trim() === '')) {
      return prev;
    }

    const hasCommentSymbol = !!curr.match(/^\s*\/\//) && !curr.match(/^\/\/\s+@/);

    if (hasCommentSymbol) {
      return { ...prev,
        commentIndentSize: indentSize
      };
    }

    return {
      commentIndentSize: null,
      lines: [...prev.lines, curr]
    };
  }, {
    commentIndentSize: null,
    lines: []
  }).lines.join('\n');
}

function babelTransform(src, filename = '') {
  let jsCode = src;

  if (filename) {
    const basename = filename.split('/').pop().replace(/\.[a-zA-Z0-9]+$/, '');
    jsCode = jsCode.replace(/%BASENAME%/g, `./${basename}`);
  }

  const {
    code
  } = babel.transformSync(jsCode, {
    presets: ['@babel/preset-react']
  });
  return code;
}

function isTransformOption(target) {
  if (Array.isArray(target) && target.length === 2 && target[0].constructor && target[0].constructor.name === 'RegExp' && typeof target[1] === 'function') {
    return true;
  }

  return false;
}

function getTransformFuncs(options) {
  const {
    transform
  } = options || {};
  return ((isTransformOption(transform) ? [transform] : transform) || []).filter(e => isTransformOption(e));
}

const lex = require('pug-lexer');

const parse = require('pug-parser');

const walk = require('pug-walk');

const transform = function (ast) {
  const nodes = [];
  walk(ast, (node, replace) => {
    let replacement;

    switch (node.type) {
      case 'Tag':
        node.attrs.forEach(attr => {
          let {
            name,
            val
          } = attr;

          if (name.startsWith('...')) {
            attr.name = `{${attr.name}}`;
            attr.val = '"__rest"';
          } else if (!/^(['"]).*\1$/.test(val)) {
            val = !/^\(.*\)$/.test(val) ? val : val.substring(1, val.length - 1);
            attr.val = `"{${!val.replace ? val : val.replace(/"/g, '\\"')}}"`;
            attr.mustEscape = false;
          }
        });
        break;

      case 'Code':
        const {
          type
        } = nodes[0] || {};
        node.val = !(type && ['Conditional', 'Each', 'Case'].includes(type)) ? `"{${node.val}}"` : `"${node.val}"`;
        node.mustEscape = false;
        return;

      case 'Conditional':
        {
          const getNodes = node => {
            const {
              type,
              test,
              consequent,
              line,
              column
            } = node;

            if (type !== 'Conditional') {
              return [{
                type: 'Text',
                val: '(',
                line,
                column
              }, node, {
                type: 'Text',
                val: '\n)',
                line,
                column
              }];
            }

            node.alternate = node.alternate || {
              type: 'Block',
              nodes: [{
                type: 'Text',
                val: '\'\'',
                line,
                column
              }],
              line
            };
            nodes.unshift(node);
            const alternate = getNodes(node.alternate);
            nodes.shift();
            const result = [{
              type: 'Text',
              val: `${node.test} ? `,
              line,
              column
            }, ...[{
              type: 'Text',
              val: '(',
              line,
              column
            }, consequent, {
              type: 'Text',
              val: ')',
              line,
              column
            }], {
              type: 'Text',
              val: ' : ',
              line,
              column
            }, ...alternate];
            return isBracketsRequired(nodes) ? wrapInBrackets(result) : result;
          };

          replacement = getNodes(node);
          replace(replacement);
          node._last = replacement[replacement.length - 1];
          replacement = null;
        }
        break;

      case 'Each':
        {
          const {
            obj,
            val,
            key,
            block,
            line,
            column
          } = node;
          replacement = [{
            type: 'Text',
            val: `__macro.for(${obj}).map((${val}${key ? `, ${key}` : ''}) => (`,
            line,
            column
          }, block, {
            type: 'Text',
            val: '))',
            line,
            column
          }];
        }
        break;

      case 'Case':
        {
          const {
            type,
            expr,
            block,
            line,
            column
          } = node;
          replacement = [{
            type: 'Text',
            val: '(() => {\n',
            line,
            column
          }, {
            type: 'Text',
            val: `switch (${expr}) {\n`,
            line,
            column
          }, ...block.nodes.map(node => [node.expr !== 'default' ? {
            type: 'Text',
            val: `case ${node.expr}:\n`,
            line,
            column
          } : {
            type: 'Text',
            val: 'default:\n',
            line,
            column
          }, {
            type: 'Text',
            val: 'return (',
            line,
            column
          }, node.block, {
            type: 'Text',
            val: ');\n',
            line,
            column
          }]), {
            type: 'Text',
            val: '}\n',
            line,
            column
          }, {
            type: 'Text',
            val: 'return null;\n',
            line,
            column
          }, {
            type: 'Text',
            val: '})()',
            line,
            column
          }];
        }
        break;

      default:
        return;
    }

    if (replacement) {
      replace(isBracketsRequired(nodes) ? wrapInBrackets(replacement) : replacement);
      node._last = replacement[replacement.length - 1];
      replacement = null;
    }

    nodes.unshift(node);
  }, node => {
    switch (node.type) {
      case 'Tag':
        nodes.shift();
        break;

      default:
        if (nodes[0] && (nodes[0] === node || nodes[0]._last === node)) {
          nodes.shift();
        }

        break;
    }
  });
  return ast;
};

function isBracketsRequired(nodes) {
  const {
    type
  } = nodes[0] || {};
  return !type || type === 'Tag';
}

function wrapInBrackets(nodes) {
  return [{
    type: 'Text',
    val: '{'
  }, ...nodes, {
    type: 'Text',
    val: '}'
  }];
}

const macro = `const __macro = {
  for: items => ({
    map: (mapFn) => {
      let mapFns = [];
      if (items && items['@@__IMMUTABLE_MAP__@@']) {
        items.mapEntries(([key, value], i) => {
          mapFns.push(mapFn(value, key, i));
        });
      } else if (items && items['@@__IMMUTABLE_LIST__@@']) {
        items.forEach((value, i) => {
          mapFns.push(mapFn(value, i, i));
        });
      } else if (Array.isArray(items)) {
        mapFns = items.map((value, index) => mapFn(value, index, index));
      } else {
        mapFns = Object.keys(items || []).map((key, index) => mapFn(items[key], key, index));
      }
      return mapFns;
    },
  }),
};
`;
var template = {
  macro
};

const works = [// combine the contents of two className attributes.
{
  post: [/\s+className=("([^"]+)"(.*)\s+className={(.*?)}((\s+[a-zA-Z0-9-]+=)|(\s*>)))/g, (context, whole, p1, p2, p3, p4, p5) => ` className={"${p2} " + (${p4})}${p3} ${p5}`]
}, // place a line break between tags
{
  post: [/(>)\s*(<[a-zA-Z])/g, (context, whole, p1, p2) => `${p1}\n${p2}`]
}, // keep the jsx syntax before pug.render and return when the conversion is done
{
  pre: [/\{([^{}]+)\}/g, (context, whole, p1) => {
    const content = p1.replace(/^\{(.*)\}$/, '$1').replace(/\n\s+\|\s+/g, ' ').replace(/\\\n\s+/g, ' ');
    const key = hashCode(content);
    context[key] = content;
    return `{__archived_${key}__}`;
  }],
  post: [/\{__archived_([a-z0-9]+)__\}/g, (context, whole, p1) => `{${context[p1]}}`]
}, // use nested components
// eg. Modal.Body
{
  pre: [/(\s*[A-Z][a-zA-Z0-9]*)\.([A-Z][a-zA-Z0-9]*)(\s|\n|\()/g, (context, whole, p1, p2, p3) => `${p1}___dot_btw_cpnts___${p2}${p3}`],
  post: [/___dot_btw_cpnts___/g, '.']
}, // use regular jsx syntax for tags: __jsx
{
  pre: [/([ (]{1})__jsx=/g, (context, whole, p1) => {
    context.index = (context.index || 0) + 1;
    return `${p1}jsx-syntax-${context.index}--=`;
  }],
  post: [/jsx-syntax-[0-9]+--=/g, '']
}, // https://reactjs.org/docs/dom-elements.html#differences-in-attributes
// class → className
// for → htmlFor
{
  post: [/\s+class="/g, ' className="']
}, {
  post: [/\s+for="/g, ' htmlFor="']
}, // comment
{
  post: [/<!--(.*?)-->/g, (context, whole, p1) => `{ /* ${p1.replace(/\/\*/g, ' ').replace(/\*\//g, ' ').trim()} */ }`]
}, // remove the double quotes surrounding the jsx grammar.
{
  post: [/="(\{.*?\})[;]{0,1}"/g, (context, whole, p1) => `=${p1.replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&amp;/g, '&')}`]
}];

const handler = {
  imports: (current, pattern) => {
    const [, moduleName, name] = current.match(pattern);
    return {
      resolve: {
        [moduleName]: name
      },
      replacement: ''
    };
  },
  decorator: (current, pattern) => {
    const [,,,, decorator] = current.match(pattern);
    return {
      startBlock: `{${decorator}(`,
      replacement: current.replace(pattern, '$1$2').replace(/\(\s*,\s*/, '('),
      endBlock: ')}'
    };
  },
  for: (current, pattern) => {
    const [,,,, parenthesesL, item,, key,, index, parenthesesR, items] = current.match(pattern);
    let paramKey;
    let paramIndex = '';

    if (!parenthesesL && !parenthesesR && !key) {
      paramKey = 'i';
    } else if (parenthesesL && parenthesesR && key) {
      paramKey = key;

      if (index) {
        paramIndex = `, ${index}`;
      }
    } else {
      return {
        startBlock: '',
        replacement: current,
        endBlock: ''
      };
    }

    return {
      startBlock: `{__macro.for(${items}).map((${item}, ${paramKey}${paramIndex}) => (`,
      replacement: current.replace(pattern, `$1$2key='{${paramKey}}'`),
      endBlock: '))}'
    };
  },
  repeat: (current, pattern) => {
    const [,,,, items, item,, index = 'i'] = current.match(pattern);
    let replacement;

    if (current.match(/[, ]key\s*=/)) {
      replacement = current.replace(pattern, '$1$2');
    } else {
      replacement = current.replace(pattern, `$1$2key='{${index}}'`);
    }

    replacement = replacement.replace(/^(\s*[^(]+\()\s*,\s*/, '$1');
    return {
      startBlock: `{(${items} || []).map((${item}, ${index}) =>`,
      replacement,
      endBlock: ')}'
    };
  },
  if: (current, pattern) => {
    const [,,,, condition] = current.match(pattern);
    return {
      startBlock: `{(${condition}) && (`,
      replacement: current.replace(pattern, '$1$2').replace(/\(\s*,\s*/, '('),
      endBlock: ')}'
    };
  },
  unless: (current, pattern) => {
    const [,,,, condition] = current.match(pattern);
    return {
      startBlock: `{!(${condition}) && (`,
      replacement: current.replace(pattern, '$1$2').replace(/\(\s*,\s*/, '('),
      endBlock: ')}'
    };
  },
  show: (current, pattern) => ({
    replacement: current.replace(pattern, (whole, p1, p2, p3, p4) => `${p1 + p2}style='{{ display: (${p4.replace(/"/g, '"')} ? "" : "none") }}'`)
  }),
  hide: (current, pattern) => ({
    replacement: current.replace(pattern, (whole, p1, p2, p3, p4) => `${p1 + p2}style='{{ display: (${p4.replace(/"/g, '"')} ? "none" : "") }}'`)
  })
};
const annotations = [// imports
{
  pattern: /^\s*\/\/\s+@import\s+([^\s]+)\s+=>\s+([^\s]+)$/,
  process: handler.imports
}, // decorator
{
  pattern: /^(\s*)(.*)(@decorator='\s*([^\s]+)\s*')/,
  process: handler.decorator
}, {
  pattern: /^(\s*)(.*)(@decorator="\s*([^\s]+)\s*")/,
  process: handler.decorator
}, // for
{
  pattern: /^(\s*)(.*)(@for='\s*([(]{0,1})\s*([^\s]+)\s*(,\s+([a-zA-Z0-9_]+)){0,1}\s*(,\s+([a-zA-Z0-9_]+)){0,1}\s*([)]{0,1})\s+in\s+([^\n]+?)\s*')/,
  process: handler.for
}, {
  pattern: /^(\s*)(.*)(@for="\s*([(]{0,1})\s*([^\s]+)\s*(,\s+([a-zA-Z0-9_]+)){0,1}\s*(,\s+([a-zA-Z0-9_]+)){0,1}\s*([)]{0,1})\s+in\s+([^\n]+?)\s*")/,
  process: handler.for
}, // repeat
{
  pattern: /^(\s*)(.*)(@repeat='\s*([^\n]+?)\s+as\s+([^\s]+)\s*(,\s+([a-zA-Z0-9_]+)){0,1}\s*')/,
  process: handler.repeat
}, {
  pattern: /^(\s*)(.*)(@repeat="\s*([^\n]+?)\s+as\s+([^\s]+)\s*(,\s+([a-zA-Z0-9_]+)){0,1}\s*")/,
  process: handler.repeat
}, // if
{
  pattern: /^(\s*)(.*)(@if='([^']+)')/,
  process: handler.if
}, {
  pattern: /^(\s*)(.*)(@if="([^"]+)")/,
  process: handler.if
}, // unless
{
  pattern: /^(\s*)(.*)(@unless='([^']+)')/,
  process: handler.unless
}, {
  pattern: /^(\s*)(.*)(@unless="([^"]+)")/,
  process: handler.unless
}, // show
{
  pattern: /^(\s*)(.*)(@show='([^']+)')/,
  process: handler.show
}, {
  pattern: /^(\s*)(.*)(@show="([^"]+)")/,
  process: handler.show
}, // hide
{
  pattern: /^(\s*)(.*)(@hide='([^']+)')/,
  process: handler.hide
}, {
  pattern: /^(\s*)(.*)(@hide="([^"]+)")/,
  process: handler.hide
}];

const j = require('jscodeshift');

const babylon = require('@babel/parser');

const parser = {
  parse(code) {
    return babylon.parse(code, {
      sourceType: 'module',
      allowImportExportEverywhere: true,
      allowReturnOutsideFunction: true,
      startLine: 1,
      tokens: true,
      plugins: ['jsx', 'asyncGenerators', 'bigInt', 'classPrivateMethods', 'classPrivateProperties', 'classProperties', 'decorators-legacy', 'doExpressions', 'dynamicImport', 'exportDefaultFrom', 'exportExtensions', 'exportNamespaceFrom', 'functionBind', 'functionSent', 'importMeta', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', ['pipelineOperator', {
        proposal: 'minimal'
      }], 'throwExpressions', 'typescript']
    });
  }

};

const getSource = (source, file) => {
  const fileExt = file.split('.').pop();

  if (fileExt === 'ts' || fileExt === 'tsx') {
    return j(source, {
      parser
    });
  }

  return j(source);
};

/* eslint-disable no-param-reassign */

const fs = require('fs');

const path = require('path');

const glob = require('glob'); // templateFn.call(this, { ... })


const isTemplateWithThis = (p, templateFuncs) => p.node.callee.object && templateFuncs.indexOf(p.node.callee.object.name) !== -1 && p.node.callee.property && p.node.callee.property.name === 'call'; // templateFn({ ... })


const isTemplateWithoutThis = (p, templateFuncs) => !p.node.callee.object && !p.node.callee.property && templateFuncs.indexOf(p.node.callee.name) !== -1;

const compareVariables = (a, b) => {
  const nameA = a.key.name.replace(/^unused_/, '');
  const nameB = b.key.name.replace(/^unused_/, '');
  const priorityA = nameA.search(/^[A-Z]/) !== -1 ? 1 : 0;
  const priorityB = nameB.search(/^[A-Z]/) !== -1 ? 1 : 0;

  if (priorityA === priorityB) {
    if (nameA === nameB) {
      return 0;
    }

    return nameA > nameB ? 1 : -1;
  }

  return priorityA > priorityB ? 1 : -1;
};

const getLinkedJsFiles = files => {
  const linkedJsFiles = glob.sync(path.join(files.path, '*.{js,jsx,ts,tsx}')).filter(file => file.search('.pug.transpiled.jsx') === -1).map(file => {
    const content = fs.readFileSync(file, 'utf8');
    const templateFuncs = getSource(content, file).find(j$1.ImportDeclaration).nodes().filter(e => {
      if (e.specifiers && e.specifiers.length === 1 && e.source.value.search('./') === 0 && path.join(files.path, e.source.value) === path.join(files.path, files.pug)) {
        return true;
      }

      return false;
    }).map(e => e.specifiers[0].local.name);
    return {
      file,
      content,
      templateFuncs
    };
  }).filter(e => e.templateFuncs.length > 0);
  return linkedJsFiles;
};

const codemod = ({
  useThis,
  variables
}, resourcePath) => {
  try {
    const filePath = resourcePath.split(path.sep).join('/');
    const files = {
      path: filePath.replace(/\/[^/]+$/, ''),
      pug: `./${filePath.replace(/\.[a-zA-Z0-9]+$/, '').split('/').pop()}.pug`
    };
    const printOptions = {
      quote: 'single',
      trailingComma: true
    };
    const jsFiles = getLinkedJsFiles(files);
    jsFiles.forEach(({
      file,
      content,
      templateFuncs
    }) => {
      let commentRemoved = content;
      getSource(content, file).find(j$1.CallExpression).filter(ce => isTemplateWithThis(ce, templateFuncs) || isTemplateWithoutThis(ce, templateFuncs)).forEach(ce => {
        const templateFuncName = ce.node.callee.object ? ce.node.callee.object.name : ce.node.callee.name;
        commentRemoved = commentRemoved.replace(new RegExp(`${templateFuncName}(.call)?\\([\\s\\S]+?}\\);`, 'g'), whole => whole.replace(/\/\/.*?\n/g, '\n'));
      });
      const breadcrumbs = {};
      const root = getSource(commentRemoved, file).find(j$1.CallExpression).filter(ce => isTemplateWithThis(ce, templateFuncs) || isTemplateWithoutThis(ce, templateFuncs)).forEach(ce => {
        const withThis = isTemplateWithThis(ce, templateFuncs);
        const templateFuncName = ce.node.callee.object ? ce.node.callee.object.name : ce.node.callee.name;
        let variableExists = false;
        let componentExists = false;
        let properties = (((ce.node.arguments || [])[withThis ? 1 : 0] || {}).properties || []).map(p => {
          const pureName = p.key.name.replace(/^unused_/, '');

          if (variables.indexOf(pureName) !== -1) {
            p.key.name = pureName;
          } else if (variables.indexOf(p.key.name) === -1) {
            p.key.name = `unused_${pureName}`;
          }

          delete p.comments;
          return p;
        });
        const oldVars = properties.map(p => p.key.name);
        properties = [...properties, ...variables.filter(p => oldVars.indexOf(p) === -1).map(e => j$1.objectProperty(j$1.identifier(e), j$1.identifier(e)))].sort(compareVariables).map(p => {
          if (!variableExists && p.key.name.search(/^[A-Z]/) === -1) {
            p.comments = [j$1.commentLine(' variables')];
            variableExists = true;
          }

          if (!componentExists && p.key.name.search(/^[A-Z]/) !== -1) {
            p.comments = [j$1.commentLine(' components')];
            componentExists = true;
          }

          if (p.value.type === 'JSXElement') {
            const jsxCode = j$1(p.value).toSource().trim(); // Wrap jsx code with parenthesis: keep

            if (jsxCode.search(/^\(/) === -1) {
              const key = `jsx__${Math.random().toString(36).substr(-6)}`;
              breadcrumbs[key] = jsxCode;
              p.value = j$1.literal(key);
            }
          }

          p.shorthand = p.key.name === p.value.name;
          return p;
        });

        if (useThis) {
          ce.node.callee = j$1.memberExpression(j$1.identifier(templateFuncName), j$1.identifier('call'));
          ce.node.arguments = [j$1.thisExpression(), properties.length > 0 ? j$1.objectExpression(properties) : null].filter(e => e);
        } else {
          ce.node.callee = j$1.identifier(templateFuncName);
          ce.node.arguments = [properties.length > 0 ? j$1.objectExpression(properties) : null].filter(e => e);
        }
      }); // Wrap jsx code with parenthesis: write down

      let result = Object.keys(breadcrumbs).reduce((prev, key) => prev.replace(new RegExp(`\n(\\s+)(.*?):\\s+'${key}'`), (whole, p1, p2) => `\n${p1}${p2}: (\n${breadcrumbs[key].split('\n').map(e => `${p1}  ${e}`).join('\n')}\n${p1})`), root.toSource(printOptions));
      templateFuncs.forEach(templateFunc => {
        result = result.replace(new RegExp(`${templateFunc}(.call)?\\([\\s\\S]+?}\\);`, 'g'), whole => whole.replace(/\n\s*\n/g, '\n'));
      });

      if (result !== content) {
        fs.writeFileSync(file, result, 'utf8');
      }
    });
  } catch (err) {
    console.error(err);
  }
};

/* eslint-disable no-param-reassign */

const addRoleAttr = content => {
  const jsxRoot = getSource(content, 'generated.jsx');
  jsxRoot.find(j$1.JSXOpeningElement).filter(e => {
    const node = e.node || {};
    const tagName = node.name && node.name.name;
    const attrs = (node.attributes || []).map(e => e.name && e.name.name);
    return !['a', 'button'].includes(tagName) && attrs.includes('onClick') && !attrs.includes('role');
  }).forEach(e => {
    e.node.attributes = [...e.node.attributes, j$1.jsxAttribute(j$1.jsxIdentifier('role'), j$1.stringLiteral('button'))];
  });
  return jsxRoot.toSource({
    quote: 'single',
    trailingComma: true
  });
};

const path$1 = require('path');

const generateCode = require('pug-code-gen');

const runtimeWrap = require('pug-runtime/wrap');

const jsxPrettierOptions = {
  parser: 'babel',
  printWidth: 120,
  tabWidth: 2,
  useTabs: false,
  semi: false,
  singleQuote: true,
  jsxSingleQuote: false,
  bracketSpacing: true,
  jsxBracketSameLine: false
};
const analyzeJsxOptions = {
  ignore: ['React']
};

const resolveModule = (moduleName, rootDir) => {
  if (moduleName && rootDir) {
    return moduleName.replace(/^@\//, `${rootDir}/`);
  }

  return moduleName;
};

const processJsxCode = (jsxCode, options, localWorks, annot, resolves) => {
  // post-processing pug.render
  // post-processing is performed in the reverse order of pre-processing
  jsxCode = localWorks.reverse().filter(({
    post
  }) => post && post.length === 2).map(({
    post,
    context
  }) => [...post, context]).reduce((prev, [pattern, replaceFn, context]) => {
    if (typeof replaceFn !== 'function') {
      return prev.replace(pattern, replaceFn);
    }

    return prev.replace(pattern, (...args) => replaceFn(context, ...args));
  }, jsxCode); // return the tag with the jsx block defined in the annotations

  jsxCode = Object.keys(annot).reduce((prev, key) => prev.replace(new RegExp(`<annot_${key}>`, 'g'), annot[key].startBlock.trim()).replace(new RegExp(`</annot_${key}>`, 'g'), annot[key].endBlock.trim()), jsxCode);
  jsxCode = getTransformFuncs(options).reduce((prev, [pattern, replaceFn]) => {
    const regexp = new RegExp(new RegExp(pattern, '').toString().replace(/^\/([\s\S]+)\/$/, '([\\s\\S])($1)([\\s\\S])'), 'g');
    return ` ${prev} `.replace(regexp, (...all) => {
      const original = all.shift();
      const args = all.slice(0, all.length - 2);
      const preChar = args.shift();
      const postChar = args.pop();
      const type = preChar === '"' && postChar === '"' ? 'attribute' : 'text';
      const replaced = replaceFn(type, ...args);

      if (typeof replaced === 'string') {
        return type === 'text' ? `${preChar}${replaced}${postChar}` : replaced;
      }

      return original;
    });
  }, jsxCode); // remove the outer brackets

  jsxCode = jsxCode.replace(/^\s*{([\s\S]+)}\s*$/, '$1'); // fix rest props

  jsxCode = jsxCode.replace(/({\.\.\..+})="__rest"/g, '$1');

  try {
    jsxCode = prettier.format(`(${jsxCode})`, jsxPrettierOptions);
  } catch (err) {
    jsxCode = prettier.format(`<>${jsxCode}</>`, jsxPrettierOptions);
  } // autofix features.


  if (options.autoFix) {
    jsxCode = addRoleAttr(jsxCode);
  }

  let result = {
    jsx: jsxCode.trim().replace(/(^;|;$)/g, '')
  };

  if (options.analyze) {
    const analyzed = analyzeJsx(result.jsx, analyzeJsxOptions);
    const {
      used,
      imports
    } = getImports(analyzed.variables, resolves);
    const variables = analyzed.variables.filter(e => used.indexOf(e) === -1);

    if (analyzed.useRequire) {
      Object.entries(analyzed.requires).forEach(([search, [replacement]]) => result.jsx = result.jsx.replace(new RegExp(search, 'g'), replacement));
    }

    result = { ...result,
      ...analyzed,
      variables,
      imports: imports.map(e => ({ ...e,
        moduleName: e.moduleName.replace(/^(\.[a-zA-Z0-9.]+)$/, '%BASENAME%$1')
      }))
    };
  }

  return result;
};

const toJsx = (source, options = {}) => {
  const localWorks = works.map(({
    pre,
    post
  }) => ({
    pre,
    post,
    context: {}
  })); // force at least two spaces between depths

  let pugCode = `\n${source.split(/\r\n/).join('\n').split(/\n/).map(e => e.replace(/^(\t*)/, (whole, p1) => p1.replace(/\t/g, '  '))).map(e => e.replace(/^(\s*)/, (whole, p1) => p1.replace(/\s/g, '  '))).join('\n')}\n`;
  pugCode = removeIndent(pugCode);
  pugCode = removePugComment(pugCode); // convert annotations to tags with preprocessing

  const {
    lines,
    annot,
    resolves
  } = pugCode.split(/\n/).reduce((dict, curr) => {
    let stepBack = '';
    const indent = Array(curr.search(/[^\s]/) + 1).join(' ');
    annotations.forEach(annotation => {
      if (curr.match(annotation.pattern)) {
        const {
          startBlock,
          replacement,
          endBlock,
          resolve
        } = annotation.process(curr, annotation.pattern);

        if (resolve) {
          dict.resolves = { ...dict.resolves,
            ...resolve
          };
        }

        if (startBlock || endBlock) {
          const content = {
            startBlock,
            endBlock
          };
          const key = hashCode(content);
          dict.lines.push(`${indent}annot_${key}`);
          dict.annot[key] = content;
          stepBack = ' ';
        }

        curr = replacement;
      }
    });
    dict.lines.push(`${stepBack}${curr}`);
    return dict;
  }, {
    lines: [],
    annot: {},
    resolves: { ...options.resolve
    }
  });

  if (!options.analyze && Object.keys(resolves).length > 0) {
    options.analyze = true;
  }

  pugCode = removeIndent(lines.join('\n')); // pre-processing pug.render

  pugCode = localWorks.filter(({
    pre
  }) => pre && pre.length === 2).map(({
    pre,
    context
  }) => [...pre, context]).reduce((prev, [pattern, replaceFn, context]) => {
    if (typeof replaceFn !== 'function') {
      return prev.replace(pattern, replaceFn);
    }

    return prev.replace(pattern, (...args) => replaceFn(context, ...args));
  }, pugCode); // remove duplicate attributes

  pugCode = removeDupAttrs(pugCode);
  const mixins = {};
  const plugins = [{
    postParse: ast => {
      ast = transform(ast);
      ast.nodes.filter(({
        type,
        call
      }) => type === 'Mixin' && !call).forEach(({
        name,
        block
      }) => mixins[name] = block);
      return ast;
    }
  }]; // pug to html

  const pugOptions = {
    pretty: true,
    filename: options.resourcePath,
    basedir: options.rootDir
  };
  const jsxCode = `\n${pug.render(pugCode, {
    plugins,
    ...pugOptions
  })}\n`;
  const result = processJsxCode(jsxCode, options, localWorks, annot, resolves);
  Object.entries(mixins).forEach(([name, ast]) => {
    const code = runtimeWrap(generateCode(ast, pugOptions))(pugOptions);
    const {
      jsx,
      useThis,
      useMacro,
      useFragment,
      variables,
      requires,
      imports
    } = processJsxCode(code, options, localWorks, annot, resolves);
    Object.entries({
      useMacro,
      useFragment
    }).forEach(([name, value]) => result[name] = result[name] || value);
    Object.assign(result.requires, requires);

    if (imports.length) {
      result.imports = Array.from(new Set(result.imports.concat(imports)));
    }

    mixins[name] = {
      jsx,
      useThis,
      variables
    };
  });
  result.mixins = mixins;
  return result;
};

const pugToJsx = (source, userOptions = {}) => {
  const options = {
    template: false,
    analyze: false,
    resolve: {},
    transform: [],
    ...userOptions
  };
  let {
    rootDir
  } = options;

  if (rootDir && options.resourcePath) {
    const [, ...rest] = options.resourcePath.split(rootDir);
    rootDir = rest.join(rootDir).split(path$1.sep).filter((e, i, arr) => e && i < arr.length - 1).fill('..').join('/');
  }

  let result = toJsx(source, { ...options,
    analyze: options.template || options.analyze
  });

  const getPragma = type => {
    switch ((type || '').trim().toLowerCase()) {
      case 'preact':
      case 'h':
        return ['preact', 'Preact'];

      case 'mithril':
      case 'm':
        return ['mithril', 'm'];

      default:
        return ['react', 'React'];
    }
  };

  const [_module, _import] = getPragma(options.pragma);

  if (options.template) {
    result.imports = result.imports.concat(Object.values(result.requires).map(([name, moduleName]) => ({
      name,
      moduleName
    })));
    const jsxTemplate = [result.useFragment ? `import ${_import}, { Fragment } from '${_module}';` : `import ${_import} from '${_module}';`, ...(result.imports || []).map(({
      name,
      member,
      moduleName
    }) => {
      const chunk = [name, member && member.length > 0 && `{ ${member.map(e => e.alias ? `${e.name} as ${e.alias}` : e.name).join(', ')} }`].filter(e => e).join(', ');
      return `import ${chunk} from '${resolveModule(moduleName, rootDir)}';`;
    }), '', result.useMacro && template.macro, `export default function (${result.variables.length > 0 ? '__params = {}' : ''}) {`, result.variables.length > 0 && `  const { ${result.variables.join(', ')} } = __params;`, '  return (', result.jsx, '  );', '}', ...Object.entries(result.mixins).map(([name, {
      jsx,
      variables
    }]) => ['\n', `export function ${name}(${variables.length > 0 ? '__params = {}' : ''}) {`, variables.length > 0 && `  const { ${variables.join(', ')} } = __params;`, '  return (', jsx, '  );', '}'].filter(Boolean).join('\n'))].filter(e => e !== false).join('\n');
    result = { ...result,
      jsxTemplate: prettier.format(jsxTemplate, { ...jsxPrettierOptions,
        semi: true
      }),
      usage: getUsage(result)
    };
  }

  return result;
};

export { addRoleAttr as addRoleButton, analyzeJsx, babelTransform, codemod, pugToJsx, removeIndent };
//# sourceMappingURL=pug-as-jsx-utils.es.js.map
